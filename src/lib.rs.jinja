// THIS FILE IS GENERATED, DO NOT EDIT

//! A wrapper around the [HID Usage Tables (HUT)](https://usb.org/document-library/hid-usage-tables-15).
//! Note that this module is created through code generation.
//!
//! In this document and unless stated otherwise, a reference to "section a.b.c" refers to the
//! [HID Device Class Definition for HID 1.11](https://www.usb.org/document-library/device-class-definition-hid-111).
//!
//! # Terminology
//!
//! See Section 5.5: a HID Usage is a 32 bit value comprising of a 16-bit Usage
//! Page and a 16-bit Usage ID.
//!
//! In this module:
//! - "Usage Page" refers to the 16-bit value. Where the Usage Page is converted
//!   to or from a 32-bit value the Usage Page is in the upper 16 bits of that value and
//!   the lower 16 bits are ignored or set to zero.
//! - "Usage ID" refers to the 16-bit value. Where the Usage ID is converted to
//!   or from a 32-bit value the Usage is in the lower 16 bits of that value and !   the upper 16 bits are ignored or set to zero.
//! - "Usage" refers to the 32-bit value comprising a Usage Page and a Usage.
//!
//! All defined [Usage]s and [UsagePage] implement [AsUsagePage] and (if applicable) [AsUsage] as
//! well as the [`From<u16>`](From), [`From<u32>`](From) and [`TryFrom<u16>`](TryFrom) conversions so that:
//! ```
//! # use hut::*;
//! let hid_usage_page: u16 = 0x01; // Generic Desktop
//! let hid_usage_id: u16 = 0x02; // Mouse
//! let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;
//!
//! // Convert to and fro the Usage either via [u32] or the [AsUsage] trait
//! let u = GenericDesktop::Mouse;
//! assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::GenericDesktop {usage: u}));
//! assert_eq!(u32::from(&u), hid_usage);
//! assert_eq!(u.usage_value(), hid_usage);
//!
//! // Convert to and fro the UsageID either via u16 or the AsUsage trait
//! assert_eq!(hid_usage_id, u16::from(&u));
//! assert_eq!(hid_usage_id, u.usage_id_value());
//!
//! // Extract the Usage Page from  Usage enum value
//! assert!(matches!(UsagePage::from(&u), UsagePage::GenericDesktop));
//! let up = UsagePage::from(&u);
//!
//! // Get the Usage Page numeric value is via the [AsUsagePage]
//! assert_eq!(hid_usage_page, u16::from(&up));
//! assert_eq!(hid_usage_page, up.usage_page_value());
//! ```
//!
//! # Button Usage Page (0x09)
//!
//! The [Button Usage Page](Button) and [Usages](Button::Button) are not autogenerated and thus
//! follow a different approach: the Usage inside the Usage Page is a simple
//! numeric usage that needs to be destructured in `match` statements.
//!
//! # Ordinals Usage Page (0x0A)
//!
//! The [Ordinals Usage Page](Ordinals) and [Usages](Ordinals::Ordinal) are not autogenerated and thus
//! follow a different approach: the Usage inside the Usage Page is a simple
//! numeric usage that needs to be destructured in `match` statements.
//!
//! # Unicode Usage Page (0x10)
//!
//! The [Unicode Usage Page](Unicode) and [Usages](Unicode::Code) are not autogenerated and thus
//! follow a different approach: the Usage inside the Usage Page is a simple
//! numeric usage that needs to be destructured in `match` statements.
//!
//! # Vendor Defined Usage Pages
//!
//! [Vendor Defined Usage Pages](VendorDefinedPage1) and [Usages](VendorDefinedPage1::VendorUsage) are not autogenerated and thus
//! follow a different approach: the Usage inside the Usage Page is a simple
//! numeric usage that needs to be destructured in `match` statements.
//!
//! # Renames
//!
//! For technical reasons, spaces, (` `), dashes (`-`), and slashes (`/`) are
//! stripped out of Usage Page and Usage names. The string representation via
//! the `Display` trait will have the unmodified value.
//!
//! Usage Pages and Usages starting with a number are translated into their
//! English word, for example [GamingControls::ThreeDGameController]. Numbers
//! inside a word are left as-is.

#![allow(clippy::identity_op, clippy::eq_op, clippy::match_single_binding)]

use std::fmt;
use std::ops::BitOr;
use thiserror::Error;

// use crate::Usage as HidUsage;

#[derive(Error, Debug)]
pub enum HutError {
    #[error("Unknown Usage Page {usage_page}")]
    UnknownUsagePage { usage_page: u16 },
    #[error("Unknown Usage")]
    UnknownUsage,
}

type Result<T> = std::result::Result<T, HutError>;

/// A trait to return the Usage and Usage ID as numeric value
pub trait AsUsage {
    fn usage_value(&self) -> u32;
    fn usage_id_value(&self) -> u16;
}

/// A trait to return the Usage Page as numeric value
pub trait AsUsagePage {
    /// Returns the 16 bit Usage Page value
    fn usage_page_value(&self) -> u16;
}

/// A HID UsagePage, see section 5.5. This represents the upper 16 bits in the
/// 32-bit
///
/// Note: this enum is generated from the HUT documents.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum UsagePage {
    {% for usage_page in usage_pages %}
    /// Usage Page `0x{{ '%X' % usage_page.value }}`: "{{usage_page.printable}}"
    ///
    /// See [{{usage_page.name}}].
    {{usage_page.name}},
    {% endfor %}
    /// The Vendor Defined Page. See [VendorDefinedPage1].
    VendorDefinedPage1,
}

impl UsagePage {
    /// Returns the Usage Page for the given Usage Page value. This is the
    /// 16-bit Usage Page value only, not the full 32-bit Usage.
    ///
    /// The returned value is always the "Undefined" usage of the matching
    /// Usage Page.
    pub fn from_usage_page_value(usage_page: u16) -> Result<UsagePage> {
        UsagePage::try_from(usage_page)
    }

    /// Returns the Usage Page for the given Usage numeric value. The Usage Page
    /// must be in the upper 16 bits of the `usage` value and the lower 16 bits
    /// are ignored.
    pub fn from_usage_value(usage: u32) -> Result<UsagePage> {
        let up: u16 = (usage >> 16) as u16;
        UsagePage::try_from(up)
    }

    /// Returns the 16-bit value for this Usage Page.
    pub fn usage_page(&self) -> u16 {
        u16::from(self)
    }

    /// Returns the 32-bit Usage that is this Usage Page combined with
    /// the 16 bits Usage ID.
    pub fn to_usage_from_value(&self, usage: u16) -> Result<Usage> {
        let up: u32 = (self.usage_page() as u32) << 16;
        let u: u32 = usage as u32;
        Usage::try_from(up | u)
    }

    pub fn to_usage(&self, usage: u16) -> Result<Usage> {
        let up: u32 = (self.usage_page() as u32) << 16;
        let u: u32 = usage as u32;
        Usage::try_from(up | u)
    }
}

impl AsUsagePage for UsagePage {
    /// Returns the 16 bit Usage Page value of this Usage Pagg
    fn usage_page_value(&self) -> u16 {
        u16::from(self)
    }
}

{% for usage_page in usage_pages %}
{% if usage_page.name not in ["VendorDefinedPage1", "Button", "Ordinals", "Unicode"] %}
/// *Usage Page `0x{{ '%X' % usage_page.value }}`: "{{usage_page.printable}}"*
///
/// **This enum is autogenerated from the HID Usage Tables**.
{% if usage_page.usages | length() >= 2 %}
/// ```
/// # use hut::*;
/// let u1 = Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage_page.usages[2].name}} };
/// let u2 = Usage::new_from_page_and_id(0x{{'%X' % usage_page.value}}, 0x{{'%X' % usage_page.usages[2].value}}).unwrap();
/// let u3 = Usage::from({{usage_page.name}}::{{usage_page.usages[2].name}});
/// assert_eq!(u1, u2);
/// assert_eq!(u1, u3);
///
/// assert_eq!(0x{{'%X' % usage_page.value}}, u1.usage_page_value());
/// assert_eq!(0x{{'%X' % usage_page.usages[2].value}}, u1.usage_id_value());
/// assert_eq!((0x{{'%X' % usage_page.value}} << 16) | 0x{{'%X' % usage_page.usages[2].value}}, u1.usage_value());
/// ```
{% endif %}
///
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum {{usage_page.name}} {
{% for usage in usage_page.usages %}
    /// Usage ID `0x{{ '%X' % usage.value}}`: "{{usage.printable}}"
    {{ usage.name }},
{% endfor %}
}

impl fmt::Display for {{usage_page.name}} {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage in usage_page.usages %}
            {{usage_page.name}}::{{usage.name}} => "{{usage.printable}}",
{% else %}
            _ => "",
{% endfor %}
        };
        write!(f, "{name}")
    }
}

{% endif %}{# if usage_page.name not in ... #}
{% endfor %}

{% for usage_page in usage_pages %}
impl AsUsage for {{usage_page.name}} {
    /// Returns the 32 bit Usage value of this Usage
    fn usage_value(&self) -> u32 {
        u32::from(self)
    }

    /// Returns the 16 bit Usage ID value of this Usage
    fn usage_id_value(&self) -> u16 {
        u16::from(self)
    }
}

impl AsUsagePage for {{usage_page.name}} {
    /// Returns the 16 bit value of this UsagePage
    ///
    /// This value is `0x{{ '%X' % usage_page.value }}` for [{{usage_page.name}}]
    fn usage_page_value(&self) -> u16 {
        let up = UsagePage::from(self);
        u16::from(up)
    }
}

impl From<&{{usage_page.name}}> for u16 {
    fn from(up: &{{usage_page.name}}) -> u16 {
        match *up {
            {% for usage in usage_page.usages %}
            {{usage_page.name}}::{{usage.name}} => {{usage.value}},
            {% endfor %}
            {% if usage_page.name == "Button" %}
            Button::Button { button } => button,
            {% endif %}
            {% if usage_page.name == "Ordinals" %}
            Ordinals::Unused => 0,
            Ordinals::Ordinal { ordinal } => ordinal,
            {% endif %}
            {% if usage_page.name == "Unicode" %}
            Unicode::Reserved => 0,
            Unicode::Code { code } => code,
            {% endif %}
        }
    }
}

impl From<{{usage_page.name}}> for u16 {
    fn from(up: {{usage_page.name}}) -> u16 {
        u16::from(&up)
    }
}

impl From<&{{usage_page.name}}> for u32 {
    fn from(usage: &{{usage_page.name}}) -> u32 {
        let up = UsagePage::from(usage);
        let up = (u16::from(&up) as u32) << 16;
        let id = u16::from(usage) as u32;
        up | id
    }
}

impl From<&{{usage_page.name}}> for UsagePage {
    fn from(_up: &{{usage_page.name}}) -> UsagePage {
        UsagePage::{{usage_page.name}}
    }
}

impl From<{{usage_page.name}}> for UsagePage {
    fn from(up: {{usage_page.name}}) -> UsagePage {
        UsagePage::from(&up)
    }
}

impl From<&{{usage_page.name}}> for Usage {
    fn from(u: &{{usage_page.name}}) -> Usage {
        Usage::try_from(u32::from(u)).unwrap()
      }
}

impl From<{{usage_page.name}}> for Usage {
    fn from(u: {{usage_page.name}}) -> Usage {
        Usage::from(&u)
      }
}

impl BitOr<u16> for {{usage_page.name}} {
    type Output = Usage;

    /// A convenience function to combine a Usage Page with
    /// a value.
    ///
    /// This function panics if the Usage ID value results in
    /// an unknown Usage. Where error checking is required,
    /// use [UsagePage::to_usage].
    fn bitor(self, usage: u16) -> Self::Output {
        let up = u16::from(self) as u32;
        let u = usage as u32;
        Usage::try_from(up | u).expect("Invalid Usage ID for this Usage Page")
    }
}

{% endfor %}

/// *Usage Page `0x9`: "Button"*
///
/// This Usage Page has only one named Usage ID, any Usages IDs in this Usage
/// Page are simply the button number.
#[derive(Debug)]
#[non_exhaustive]
pub enum Button {
    /// Usage ID `0x0`: "No Buttons Pressed"
    NoButtonsPressed,
    Button {
        button: u16,
    },
}

impl fmt::Display for Button {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            Button::NoButtonsPressed => "No Buttons Pressed".to_string(),
            Button::Button { button } => format!("Button {button}"),
        };
        write!(f, "{name}")
    }
}

/// *Usage Page `0xA`: "Ordinals"*
///
/// This Usage Page has only one named Usage ID, any Usages IDs in this Usage
/// Page are simply the ordinal number.
#[derive(Debug)]
#[non_exhaustive]
pub enum Ordinals {
    /// Usage ID `0x0`: "Reserved"
    Unused,
    Ordinal { ordinal: u16 },
}

impl fmt::Display for Ordinals {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            Ordinals::Unused => "Unused".to_string(),
            Ordinals::Ordinal { ordinal } => format!("Ordinal {ordinal}"),
        };
        write!(f, "{name}")
    }
}


/// *Usage Page `0x10`: "Unicode"*
///
/// This Usage Page has only one named Usage ID, any Usages IDs in this Usage
/// Page are simply the code point.
#[derive(Debug)]
#[non_exhaustive]
pub enum Unicode {
    /// Usage ID `0x0`: "Reserved"
    Reserved,
    Code { code: u16 },
}

impl fmt::Display for Unicode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            Unicode::Reserved => "Reserved".to_string(),
            Unicode::Code { code } => format!("Code {code}"),
        };
        write!(f, "{name}")
    }
}

/// *Usage Page `0xff00`: The Vendor Defined Page*
///
/// This Usage Page has no named Usage IDs, any Usages in this Usage Page are
/// private to a vendor implementation.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum VendorDefinedPage1 {
    Undefined,
    VendorUsage { usage_id: u16 },
}

impl fmt::Display for VendorDefinedPage1 {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
            VendorDefinedPage1::Undefined => "Vendor Usage Undefined".to_string(),
            VendorDefinedPage1::VendorUsage { usage_id } => {
                format!("Vendor Usage 0x{usage_id:02x}")
            }
        };
        write!(f, "{name}")
    }
}

impl From<&Usage> for UsagePage {
    fn from(usage: &Usage) -> UsagePage {
        match usage {
{% for usage_page in usage_pages %}
            Usage::{{usage_page.name}} { .. } => UsagePage::{{usage_page.name}},
{% endfor %}
            Usage::VendorDefinedPage1 { .. } => UsagePage::VendorDefinedPage1,
        }
    }
}

impl From<&UsagePage> for u16 {
    /// Returns the UsagePage as 16-bit value. This is equivalent to the
    /// upper 16 bits of a full 32-bit Usage value shifted down.
    fn from(usage_page: &UsagePage) -> u16 {
        match usage_page {
{% for usage_page in usage_pages %}
            UsagePage::{{usage_page.name}} { .. } => {{usage_page.value}},
{% endfor %}
            UsagePage::VendorDefinedPage1 { .. } => 0xff00,
        }
    }
}

impl From<UsagePage> for u16 {
    fn from(usage_page: UsagePage) -> u16 {
        u16::from(&usage_page)
    }
}

impl TryFrom<u16> for UsagePage {
    type Error = HutError;

    fn try_from(usage_page: u16) -> Result<UsagePage> {
        match usage_page {
{% for usage_page in usage_pages %}
            {{usage_page.value}} => Ok(UsagePage::{{usage_page.name}}),
{% endfor %}
            0xff00 => Ok(UsagePage::VendorDefinedPage1),
            n => Err(HutError::UnknownUsagePage { usage_page: n }),
        }
    }
}

impl fmt::Display for UsagePage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage_page in usage_pages %}
            UsagePage::{{usage_page.name}} => "{{usage_page.printable}}",
{% endfor %}
            UsagePage::VendorDefinedPage1 => "Vendor Defined Page 1",
        };
        write!(f, "{name}")
    }
}

/// An enum wrapping all known Usages in the HUT.
/// ```
/// # use hut::*;
/// let u1 = Usage::GenericDesktop { usage: GenericDesktop::Mouse};
/// let u2 = Usage::new_from_page_and_id(0x01, 0x02).unwrap();
/// assert_eq!(u1, u2);
///
/// assert_eq!(0x1, u1.usage_page_value());
/// assert_eq!(0x2, u1.usage_id_value());
/// assert_eq!(0x1 << 16 | 0x2, u1.usage_value());
/// ```
/// Note: this enum is generated from the HUT documents.
#[allow(non_camel_case_types)]
#[derive(Debug)]
#[non_exhaustive]
pub enum Usage {
    {% for usage_page in usage_pages %}
    /// "{{usage_page.printable}}"
    {{usage_page.name}} {
        usage: {{usage_page.name}},
    },
    {% endfor %}
    VendorDefinedPage1 {
        usage: VendorDefinedPage1,
    },
}

impl Usage {
    pub fn new_from_page_and_id(usage_page: u16, usage_id: u16) -> Result<Usage> {
        Usage::try_from((usage_page as u32) << 16 | usage_id as u32)
    }
}

impl AsUsage for Usage {
    /// Returns the 32 bit Usage value for this usage.
    fn usage_value(&self) -> u32 {
        self.into()
    }

    /// Returns the 16-bit Usage ID value for this usage.
    fn usage_id_value(&self) -> u16 {
        self.into()
    }
}

impl PartialEq for Usage {
    fn eq(&self, other: &Self) -> bool {
        u32::from(self) == u32::from(other)
    }
}

impl AsUsagePage for Usage {
    fn usage_page_value(&self) -> u16 {
        UsagePage::from(self).into()
    }
}

impl fmt::Display for Usage {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let name = match self {
{% for usage_page in usage_pages %}
            Usage::{{usage_page.name}} { usage } => format!("{usage}"),
{%  else %}
            _ => "".into(),
{% endfor %}
            Usage::VendorDefinedPage1 { usage } => format!("{usage}"),
        };
        write!(f, "{name}")
    }
}

impl From<&Usage> for u16 {
    fn from(usage: &Usage) -> u16 {
        let u: u32 = u32::from(usage);
        (u & 0xFFFF) as u16
    }
}

impl From<Usage> for u16 {
    fn from(usage: Usage) -> u16 {
        u16::from(&usage)
    }
}

impl From<&Usage> for u32 {
    fn from(usage: &Usage) -> u32 {
        match usage {
{% for usage_page in usage_pages %}
{% for usage in usage_page.usages %}
            Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage.name}} } => {{usage_page.value}} << 16 | {{usage.value}},
{% endfor  %}
{% endfor  %}
            Usage::Button { usage: Button::Button { button } } => 0x090000 | *button as u32,
            Usage::Ordinals { usage: Ordinals::Ordinal { ordinal } } => 0x0A0000 | *ordinal as u32,
            Usage::Unicode { usage: Unicode::Code { code } } => 0x100000 | *code as u32,
            Usage::VendorDefinedPage1 { usage: VendorDefinedPage1::Undefined } => 0xff000000,
            Usage::VendorDefinedPage1 { usage: VendorDefinedPage1::VendorUsage { usage_id } } => 0xff00000u32 | *usage_id as u32,
            _ => panic!("Unhandled usage {usage:?}"),
        }
    }
}

//impl TryFrom<&HidUsage> for Usage {
//    type Error = HutError;
//
//    fn try_from(usage: &HidUsage) -> Result<Usage> {
//        let up = u16::from(usage.usage_page);
//        let u = u16::from(usage.usage_id);
//        Usage::new_from_page_and_id(up, u)
//    }
//}

impl TryFrom<u32> for Usage {
    type Error = HutError;

    fn try_from(up: u32) -> Result<Usage> {
        match (up >> 16, up & 0xFFFF) {
{% for usage_page in usage_pages %}
{% for usage in usage_page.usages %}
            ({{usage_page.value}},  {{usage.value}}) => Ok(Usage::{{usage_page.name}} { usage: {{usage_page.name}}::{{usage.name}} }),
{% endfor  %}
{% endfor  %}
            (0x0009, n) => Ok(Usage::Button { usage: Button::Button { button: n as u16 } }),
            (0x000a, n) => Ok(Usage::Ordinals { usage: Ordinals::Ordinal { ordinal: n as u16 } }),
            (0x0010, n) => Ok(Usage::Unicode { usage: Unicode::Code { code: n as u16 } }),
            (0xff00, n) => Ok(Usage::VendorDefinedPage1 { usage: VendorDefinedPage1::VendorUsage { usage_id: n as u16 } }),
            (_, _) => Err(HutError::UnknownUsage),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn conversions() {
        let hid_usage_page: u16 = 0x01; // Generic Desktop
        let hid_usage_id: u16 = 0x02; // Mouse
        let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;

        let u = GenericDesktop::Mouse;
        // 32 bit usage to enum
        assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::GenericDesktop {usage: _}));

        // Usage to u32
        assert_eq!(u32::from(&u), hid_usage);
        assert_eq!(u.usage_value(), hid_usage);

        // Usage to u16 usage_id
        assert_eq!(hid_usage_id, u16::from(&u));
        assert_eq!(hid_usage_id, u.usage_id_value());

        // Usage to UsagePage
        assert!(matches!(UsagePage::from(&u), UsagePage::GenericDesktop));

        // UsagePage to u16
        let up = UsagePage::from(&u);
        assert_eq!(hid_usage_page, u16::from(&up));

        // UsagePage to u16 via AsUsagePage trait
        assert_eq!(hid_usage_page, up.usage_page_value());
    }

    #[test]
    fn buttons() {
        let hid_usage_page: u16 = 0x9;
        let hid_usage_id: u16 = 0x5;
        let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;

        let u = Button::Button { button: 5 };
        assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::Button { usage: _ }));

        // Usage to u32
        assert_eq!(u32::from(&u), hid_usage);
        assert_eq!(u.usage_value(), hid_usage);

        // Usage to u16 usage_id
        assert_eq!(hid_usage_id, u16::from(&u));
        assert_eq!(hid_usage_id, u.usage_id_value());

        // Usage to UsagePage
        assert!(matches!(UsagePage::from(&u), UsagePage::Button));

        // UsagePage to u16
        let up = UsagePage::from(&u);
        assert_eq!(hid_usage_page, u16::from(&up));

        // UsagePage to u16 via AsUsagePage trait
        assert_eq!(hid_usage_page, up.usage_page_value());
    }

    #[test]
    fn ordinals() {
        let hid_usage_page: u16 = 0xA;
        let hid_usage_id: u16 = 0x8;
        let hid_usage: u32 = (hid_usage_page as u32) << 16 | hid_usage_id as u32;

        let u = Ordinals::Ordinal { ordinal: 8 };
        assert!(matches!(Usage::try_from(hid_usage).unwrap(), Usage::Ordinals { usage: _ }));

        // Usage to u32
        assert_eq!(u32::from(&u), hid_usage);
        assert_eq!(u.usage_value(), hid_usage);

        // Usage to u16 usage_id
        assert_eq!(hid_usage_id, u16::from(&u));
        assert_eq!(hid_usage_id, u.usage_id_value());

        // Usage to UsagePage
        assert!(matches!(UsagePage::from(&u), UsagePage::Ordinals));

        // UsagePage to u16
        let up = UsagePage::from(&u);
        assert_eq!(hid_usage_page, u16::from(&up));

        // UsagePage to u16 via AsUsagePage trait
        assert_eq!(hid_usage_page, up.usage_page_value());
    }
}
